关于java中多线程同步。乐观锁悲观锁以及synchronized锁机制，volatile关键字，CAS算法记录


悲观锁乐观锁的简单解释：

悲观锁：  有锁
               （1）在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。

               （2）一个线程持有锁会导致其它所有需要此锁的线程挂起。

               （3）如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险

                在执行代码时，如果使用悲观锁，例如synchronized关键字，以及sql中的for update语句。会导致其它想要执行这个方法的线程被挂起
                当持有锁的对象释放锁时，系统会从众多等待的线程中选择去执行


乐观锁：  无锁
                每次不加锁去执行某个操作，如果有冲突，则失败不执行，进行重试，直到成功为止。例如：CAS机制，sql中例如加入version版本号





CAS篇幅:

                什么是CAS：compare and swap的缩写，中文翻译成比较并交换
                在java.util.concurrent包中，CAS理论是它实现整个java包的基石。

                CAS操作包含三个操作数——————内存位置（V），预期原值（A）和新值(B)。
                如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值
                (在 CAS 的一些特殊情况下将仅返回CAS是否成功，而不提取当前值。)
                CAS 有效地说明了“我认为位置V应该包含值A；如果包含该值，则将B放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”
                通常将 CAS 用于同步的方式是从地址 V 读取值 A，执行多步计算来获得新 值 B，然后使用 CAS 将 V 的值从 A 改为 B。如果 V 处的值尚未同时更改，则 CAS 操作成功。
                类似于 CAS 的指令允许算法执行读-修改-写操作，而无需害怕其他线程同时 修改变量，因为如果其他线程修改变量，那么 CAS 会检测它（并失败），算法可以对该操作重新计算。（拥有失败重试机制）
                相对于synchronized机制，CAS在性能上有很大的提升

CAS存在的问题：(1)ABA问题。所谓ABA问题就是CAS在操作时会检测值有没有发生变化，但是如果一个值原来是A，变成了B，又变成了A，那么CAS检测时会发现这个值并没有发生变化，但实际上这个值时发生了变化的
                解决方法：前文有讲。加入version版本号，在每次变量更新的时候，把版本号加一，那么A-B-A 就会变成1A-2B-3A
                但是从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。
                这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志（相当于version），如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

                new对象：AtomicStampedReference atomicStampedReference=new AtomicStampedReference(第一个参数代表最初的引用,第二个参数代表最初的标志);
                compareAndSet方法：atomicStampedReference.compareAndSet(预计引用,新的引用,预计标志,新的标志);
             (2)只能保证一个共享变量的原子操作。这个时候可以用锁或者把多个共享变量合并成一个共享变量来操作。
                eg：有两个共享变量 i=2,j=a,合并一下，ij=2a。然后用CAS操作ij
                从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作
                concurrent包内部的类都申明了共享变量为volatile



关于volatile变量：

                synchronized是一个重量级的锁，而volatile修饰变量则是轻量级的锁，因为访问volatile变量时不会执行加锁操作
                其实也就是一种一种稍弱的同步机制，是用来确保将变量的更新操作通知到其他线程

                java对于volatile的定义：Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量

                解释：(排他锁：又称为写锁。若对数据加了排他锁，则其它事务与线程不能再对这个数据加锁，直到释放锁。这就保证了其它线程在锁释放前不能够再读取和修改此数据)

                用volatile修饰的变量具有可见性。也就是说一个线程修改的结果，另一个线程马上就能看到。但是volatile不具有原子性。当然，synchronize和锁都可以保证可见性。

                当对非volatile变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的CPU cache 中
                而声明变量是volatile的，JVM保证了每次读变量都从内存中读，跳过CPU cache这一步。
                当一个变量被volatile修饰后，表示着线程本地内存无效，当一个线程修改共享变量后他会立即被更新到主内存中，当其他线程读取共享变量时，它会直接从主内存中读取
                volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的
                volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行，在JVM底层volatile是采用“内存屏障”来实现的

                总结：保证可见性，不保证原子性，禁止指令重排序
                     使用volatile必须满足以下条件：1.对变量的写操作不依赖当前值 2.该变量没有包含在具有其它变量的不变式中




多线程中都会提到的可见性，原子性，有序性:

                可见性：是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。
                       在多线程环境下，一个线程对共享变量的操作对其他线程是不可见的，Java提供了volatile来保证可见性

                原子性：如果一个操作是不可分割的，那么我们说这个操作是原子操作
                       即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行
                       在Java中，对基本数据类型的变量和赋值操作都是原子性操作
                       在单线程环境下我们可以认为整个步骤都是原子性操作，但是在多线程环境下则不同，Java只保证了基本数据类型的变量和赋值操作才是原子性的
                       要想在多线程环境下保证原子性，则可以通过锁、synchronized来确保
                       什么叫不具有原子性：比如volatile int a=0;  之后执行a++ 这个变量啊具有可见性，但是a++依然是一个非原子操作，还是存在线程安全问题。
                       备注:能拆分的都叫非原子操作 例如a++ 其实是a=a+1     但是像a=0;就叫原子操作     j = i ; 但是像这种不是，它包含了两个操作：读取i，将i值赋值给j
                       在 Java 中 synchronized操作保证原子性

                有序性：即程序执行的顺序按照代码的先后顺序执行
                       在Java内存模型中，为了效率是允许编译器和处理器对指令进行重排序
                       Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 是因为其本身就包含“禁止指令重排序”的语义，前文有提到
                       synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行。串行则代表有序
                       ps：学过物理的应该都知道串行和并行的区别吧








